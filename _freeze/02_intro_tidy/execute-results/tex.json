{
  "hash": "7325d318c1661e285a63532bc5aa6011",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introdução ao _tidyverse_\"\nauthor:\n  - name: Paulo Barros\n    orcid: 0000-0001-9839-0796\n    email: pbarrosbio@gmail.com\n    affiliations:\n      - name: PPZ - UESB - GACOM\n---\n\n\n\n\n\n\n## Filosofias de código\n\nComo em toda linguagem de programação, respeitando-se a sintaxe, existem\ndiferentes maneiras de se resolver o mesmo problema, e também de escrever código\nem R. \n\nA escolha da filosofia de cógido ou estilo de código é puramente pessoal.\nHá quem prefira programar usando o que chamamos de _Base R_ ou R Base. Esse\nestilo baseia-se em utilizar puramente a sintaxe original da linguagem, não\nsendo dependente de pacotes que necessitem de constantes atualizações. Porém,\nesse também é um caminho com uma curva de aprendizado mais elevada para os\nque nunca tiveram contato com programação.\n\nUma filosofia alternativa e que hoje tem se tornado cada vez mais o padrão\ninicial de introdução ao R é o caminho do `tidyverse`. Um conjunto de pacotes\npensado para tornar a vida do usuário de R mais fácil seus códigos mais\nintuitivos e legíveis.\n\nSe você ainda não instalou este pacote pode usar\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{#lst-inst-pkg .r .cell-code  lst-cap=\"Instalando Pacotes\"}\ninstall.packages('tidyverse')\n```\n:::\n\n\n\n\n\n\n\n\nE se ainda tem dúvidas de como instalar pacotes no R\n[dá uma olhada aqui.](01_r_rstudio.qmd#sec-inst-pkg).\n\nSe já estiver tudo instalado podemos carregar o nosso pacote com \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n\n\n\n## Diretório de Trabalho\n\nO diretório de trabalho é a pasta raiz na qual a sua sessão do R atual está\nbaseada e procurará pelos arquivos de dados, e também aonde salvará arquivos\ngerados como resultados de alguma função.\n\nVocê pode definir o seu diretório de trabalho indo no menu _Session > Set \nWorking Directory > Change Directory..._ ou usar o atalho `CTRL + Shift + H`.\nNa janela que aparece a seguir, basta escolher a pasta que deseja utilizar como\nseu diretório de trabalho.\n\nO passo anterior nada mais é do que uma maneira visual de invocar a função\n`setwd`. Esta função recebe como argumento um caminho de diretório e o define\ncomo diretório de trabalho.\n\n::: {.callout-warning}\n# Atenção com os caminhos de diretório!\n\nAo definir os caminhos de diretório via código com `setwd` é importante prestar\natenção a como o caminho é definido no seu sistema operacional.\n\n{{< fa brands windows >}} `C:\\Users\\SeuNome\\Documents\\Projeto`\n\n{{< fa brands linux >}} {{< fa brands apple >}} `/home/SeuNome/Documentos/Projeto`\n\nNote a diferença entre os usos da `\\` e `/` nos diferentes sistemas. Qualquer\nerro na escrita do caminho acarretará em um erro na função já que não será\npossível encontrar o diretório especificado.\n\nAo criar diretórios em seu computador evite usar caracteres especiais, nomes\nlongos e espaços. Torne sua vida mais fácil!\n\n:::\n\n## Projetos em R\n\nUm projeto em R é um arquivo com extensão `.Rproj` que mantém todos os arquivos\nem um diretório (scripts, dados, figuras, etc.) em um grupo. Quando criamos um\nprojeto em R automaticamente o nosso diretório de trabalho é definido como a pasta\nque contém o nosso arquivo `.Rproj`. Isso facilita o trabalho colaborativo e \nevita problemas de definição de caminhos de arquivos.\n\nPara criar um novo projeto voce pode acessar o menu _File > New Project..._ ou\nusar o botão ![](images/project_icon.png) no canto superior direito do seu RStudio.\nPara abrir um projeto existente pode acessar _File > Open project..._ e escolher\no projeto que deseja abrir.\n\nQuando criamos um projeto temos a opção de criar um novo diretório associado ao\nprojeto, ou podemos usar um diretório já criado previamente e associá-lo a nosso\nprojeto.\n\n::: {.callout-tip}\n# Organização é tudo!\n\nAcostume-se a organizar o seu diretório de trabalho criando subdiretórios para\narmazenar os diferentes arquivos do seu projeto. Você pode por exemplo usar\numa pasta para os scripts, uma para os seus dados, outras para os resultados, etc.\n  \n:::\n\n## Entrada de Dados\n\nNo R é possível fazer o carregamento de dados nos mais diversos formatos. Os \narquivos em formato de texto (`.csv`,`.txt`) são os mais compatíveis entre\ndiferentes plataformas. Mas é possível também carregar por exemplo arquivos em\nformato de planilhas como `.xls` e `.xlsx`. \n\nEmbora seja possível fazer o carregamento dos arquivos de maneira visual usando\no botão ![](images/import_data.png) na aba _Environment_, é recomendado que você\nse acostume a carregar os seus dados diretamente via script uma vez que em\ndeterminadas aplicações você não terá acesso a interface do RStudio para executar\num fluxo de análises em um servidor remoto por exemplo.\n\n### Importando arquivos de texto\n\nPara importar um arquivo `.csv` é preciso ter atenção ao tipo de arquivo. CSV\nsignifica _Comma Separated Values_ ou _Arquivo separado por vírgulas_, entretanto,\né comum principalmente no Windows que arquivos `.csv` sejam gerados utilizando\n`;` como separador de campos.\n\nPara os exemplos a seguir utilizaremos alguns conjuntos de dados de exemplo, no\nmeu setup estes arquivos estão dentro de um diretório chamado `data`. Podemos\nusar o comando `list.files` para visualizar os arquivos disponíveis nessa pasta:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(path = \"data\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data_cows.txt\"       \"dietas_galinha.xlsx\" \"NELP365.csv\"        \n[4] \"NELP550.csv\"         \"NELPN.csv\"           \"Peso365.csv\"        \n```\n\n\n:::\n:::\n\n\n\n\n\n\nO argumento `path` informa em qual pasta desejo listar os meus arquivos, se \nomitirmos esse argumento o comando fará a busca no diretório raiz que está\nsetado como diretório de trabalho na sessão atual.\n\nVocê pode consultar qual diretório é o atual de trabalho com o comando `getwd`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/paulo/Insync/pbarrosbio@gmail.com/Google Drive/PROJECTS/intro_r_tidyverse\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nVamos importar o arquivo `Peso365.csv`, este é um arquivo `.csv` padrão que tem\nos campos separados por vírgulas. Você pode abrir o arquivo para inspecioná-lo\nem um editor de texto por exemplo.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np365 <- read.csv(file = \"data/Peso365.csv\")\n```\n:::\n\n\n\n\n\n\nNo comando acima estamos fazendo a leitura do nosso arquivo e armazenando em um\nobjeto chamado `p365`. Podemos testar se a nossa importação foi bem sucedida\npedindo para exibir as linhas iniciais e finais do nosso arquivo com os\ncomandos `head` e `tail` respectivamente.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(p365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Animal Pai P365\n1      1   A  322\n2      2   A  324\n3      3   A  321\n4      4   A  330\n5      5   A  327\n6      6   A  325\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(p365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Animal Pai P365\n31     31   F  311\n32     32   F  333\n33     33   F  317\n34     34   F  315\n35     35   F  330\n36     36   F  318\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n::: {.callout-tip}\n# Perguntar não custa nada!\n\nLembre-se que você pode pedir ajuda ao R sobre qualquer função. \n\n`help(head)`\n`help(tail)`\n\n:::\n\nNem todo arquivo de texto é separado por algum caracter especial, alguns utilizam\nespaços ou tabulações para separar os campos. Agora iremos importar o arquivo\n`data_cows.txt`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncows <- read.table(file = \"data/data_cows.txt\",\n                   header = TRUE)\n```\n:::\n\n\n\n\n\n\nObserve que neste caso precisamos informar o argumento `header` que indica para\na função se o nosso arquivo possui um cabeçalho de colunas ou não. Esse é um\ndetalhe importante na hora de importar arquivos no R, uma vez que se não informamos\na presença de uma linha de cabeçalho a função criará novos nomes para as colunas\ne a linha de cabeçalho sera interpretada como uma linha de dados.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(cows)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  animal   iron      infect weight day\n1    A01 NoIron NonInfected    110 122\n2    A01 NoIron NonInfected    135 150\n3    A01 NoIron NonInfected    150 166\n4    A01 NoIron NonInfected    160 179\n5    A01 NoIron NonInfected    170 219\n6    A01 NoIron NonInfected    175 247\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(cows)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    animal iron   infect weight day\n593    A26 Iron Infected    325 627\n594    A26 Iron Infected    325 655\n595    A26 Iron Infected    325 668\n596    A26 Iron Infected    340 723\n597    A26 Iron Infected    335 751\n598    A26 Iron Infected    345 781\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Importando arquivos de Excel\n\nPara importar arquivos no formato do Excel é necessário a utilização do pacote\n`readxl`. Se não tiver instalado faça a instalação:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readxl\")\n```\n:::\n\n\n\n\n\n\nUma vez instalado podemos carregaro pacote e fazer a importação do nosso arquivo\n`dietas_galinhas.xslx`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n\ngalinhas <- read_xlsx(path = \"data/dietas_galinha.xlsx\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 6\n    rep `Dieta A` `Dieta B` `Dieta C` `Dieta D` `Dieta E`\n  <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n1     1       179       309       243       423       368\n2     2       160       229       230       340       390\n3     3       136       181       248       392       379\n4     4       227       141       327       339       260\n5     5       217       260       329       341       404\n6     6       168       203       250       226       318\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 6\n    rep `Dieta A` `Dieta B` `Dieta C` `Dieta D` `Dieta E`\n  <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n1     1       179       309       243       423       368\n2     2       160       229       230       340       390\n3     3       136       181       248       392       379\n4     4       227       141       327       339       260\n5     5       217       260       329       341       404\n6     6       168       203       250       226       318\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Alguns comandos úteis\n\nAlguns comandos básicos são bastante úteis para verificar a sanidade dos dados\nna hora da importação. Se você olhar na sua aba _Environment_ vai perceber que\ntodos os objetos que criamos ao importar os dados agora estão listados.\n\nPodemos visualizar os nossos dados dando um duplo clique sobre o objeto desejado\nou usando a função `View`. Isso abrirá nosso conjunto de dados no visualizador\ndo RStudio.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(p365)\n```\n:::\n\n\n\n\n\n\n::: {.callout-warning}\n# Atenção!\n\nCuidado ao tentar visualizar conjuntos de dados muito grandes, isso pode consumir\numa quantidade significativa de memória e até mesmo causar uma parada da sua\nsessão no R.\n  \n:::\n\nAlguns outros comandos úteis incluem:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exibe os nomes das colunas de um data.frame\n\nnames(p365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Animal\" \"Pai\"    \"P365\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Exibe informações sobre a estrutura do conjunto de dados\n\nstr(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [6 x 6] (S3: tbl_df/tbl/data.frame)\n $ rep    : num [1:6] 1 2 3 4 5 6\n $ Dieta A: num [1:6] 179 160 136 227 217 168\n $ Dieta B: num [1:6] 309 229 181 141 260 203\n $ Dieta C: num [1:6] 243 230 248 327 329 250\n $ Dieta D: num [1:6] 423 340 392 339 341 226\n $ Dieta E: num [1:6] 368 390 379 260 404 318\n```\n\n\n:::\n\n```{.r .cell-code}\n# Exibe o tipo de objeto\n\nclass(p365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPercebeu a diferença entre o tipo de objeto `p365` e `galinhas`? O primeiro é do\ntipo `data.frame` que é o objeto padrão de tabelas do R. O segundo é do tipo\n`tbl_df` que é um tipo especial de `data.frame` com algumas melhorias. A este\ntipo de tabela é chamada de `tibble`, e é o formato padrão de tabelas utilizados\npelo pacote `tidyverse`. A partir daqui comecaremos a utilizar as funções deste\npacote, então se ainda não instalou veja o código em @lst-inst-pkg {{< fa angry >}}.\n\n## Selecionando variáveis\n\nSe ainda não carregou o `tidyverse` a hora é agora.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.4     v readr     2.1.5\nv forcats   1.0.0     v stringr   1.5.1\nv ggplot2   3.5.1     v tibble    3.2.1\nv lubridate 1.9.3     v tidyr     1.3.1\nv purrr     1.0.2     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSeleção de variáveis é uma das tarefas mais triviais na edição de dados. Muitas\ndas vezes precisamos fazer recortes nos dados, ou selecionar um conjunto específico\nde variáveis ou até mesmo uma única variável para executar operações.\n\nPara isso podemos utilizar a função `select` que é parte do pacote `dplyr`, um dos\ncomponentes do `tidyverse`. Vamos relembrar os nomes das nossas colunas no dataset\n`galinhas`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rep\"     \"Dieta A\" \"Dieta B\" \"Dieta C\" \"Dieta D\" \"Dieta E\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(galinhas,\"Dieta A\",\"Dieta C\",\"Dieta E\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  `Dieta A` `Dieta C` `Dieta E`\n      <dbl>     <dbl>     <dbl>\n1       179       243       368\n2       160       230       390\n3       136       248       379\n4       227       327       260\n5       217       329       404\n6       168       250       318\n```\n\n\n:::\n:::\n\n\n\n\n\n\nObserve que na hora de informar as colunas a selecionar eu precisei usar `\"\"` já\nno nome das variáveis existe um espaço sendo usado. Por isso que é sempre recomendado\nevitar este tipo de nomes de variáveis, quanto mais pudermos facilitar a nossa\nvida melhor! Mas essa é uma boa oportunidade para apresentar mais um pacote útil.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"janitor\")\n```\n:::\n\n\n\n\n\n\nO pacote `janitor` é muito útil na hora de realizar tarefas de sanitização de\ndados. Vamos usar esse pacote para renomear as nossas colunas de uma maneira\nmais legível e compatível com a sintaxe do R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'janitor'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n```\n\n\n:::\n\n```{.r .cell-code}\nclean_names(galinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 6\n    rep dieta_a dieta_b dieta_c dieta_d dieta_e\n  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1     1     179     309     243     423     368\n2     2     160     229     230     340     390\n3     3     136     181     248     392     379\n4     4     227     141     327     339     260\n5     5     217     260     329     341     404\n6     6     168     203     250     226     318\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPercebam que embora tenhamos utilizado a função `clean_names` nosso conjunto de\ndados continua o mesmo já que não atualizamos o nosso objeto para fixar as\nmudanças que fizemos.\n\nMuitas vezes não queremos alterar o nosso objeto original e podemos criar novos\nobjetos, ou simplesmente sobrescrever o objeto antigo com o novo com as mudanças\naplicadas. Vamos atualizar o nosso objeto.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# limpando os nomes das colunas e sobrescrevendo o nosso objeto\n\ngalinhas <- clean_names(galinhas)\n\n# fazendo novamente a seleção das variáveis agora com \n# as colunas renomeadas\n\nselect(galinhas,dieta_a, dieta_c,dieta_e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  dieta_a dieta_c dieta_e\n    <dbl>   <dbl>   <dbl>\n1     179     243     368\n2     160     230     390\n3     136     248     379\n4     227     327     260\n5     217     329     404\n6     168     250     318\n```\n\n\n:::\n:::\n\n\n\n\n\n\nObservem que agora que compatibilizamos o nome das nossas colunas o uso de `\"\"`\nnão é mais necessário, podemos simplesmente passar pra função o nome das colunas.\n\n### Seleção de intervalos\n\nEm R o caracter `:` é utilizado para gerar um intervalo. Por exemplo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPodemos utilizar esse operador também para selecionar intervalos de colunas/variáveis:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(galinhas, dieta_a:dieta_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  dieta_a dieta_b dieta_c\n    <dbl>   <dbl>   <dbl>\n1     179     309     243\n2     160     229     230\n3     136     181     248\n4     227     141     327\n5     217     260     329\n6     168     203     250\n```\n\n\n:::\n:::\n\n\n\n\n\n\nO tipo de seleção com a função `select` sempre retorna um `data.frame` ou uma `tibble`. Mas podemos também querer acessar os valores de determinada coluna como um vetor. Para isso podemos usar `$` para indexar a coluna que quisermos.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalinhas$rep\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\ngalinhas$dieta_a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 179 160 136 227 217 168\n```\n\n\n:::\n:::\n\n\n\n\n\n\nA notação `$` é do R Base, mas podemos realizar a mesma operação usando a função `pull` do `dplyr`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(galinhas, rep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Filtros\n\nA função `filter` nos permite selecionar subgrupos dos nossos dados baseado em\ncritérios fornecidos. Os filtros podem ser baseados em operadores matemáticos\n\n* `<` menor que\n* `>` maior que\n* `==` igual\n* `!=` diferente\n\nou pode também usar outras funções condicionais como `is.na()` que testa se uma\nvariável contém dados faltantes `NA`, ou `between(a,b)` que checa se os valores\nestão em um determinado intevalo definido.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(p365,\n       Pai == \"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Animal Pai P365\n1      1   A  322\n2      2   A  324\n3      3   A  321\n4      4   A  330\n5      5   A  327\n6      6   A  325\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(p365$P365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  298.0   318.8   323.0   322.2   328.0   338.0 \n```\n\n\n:::\n\n```{.r .cell-code}\nfilter(p365,\n       between(P365, 280, 310))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Animal Pai P365\n1     19   D  306\n2     23   D  300\n3     24   D  298\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Pipe\n\nEm um fluxo de análises é comum realizarmos tarefas sequenciais. O operador _Pipe_ `|>`\nnos permite combinar funções em sequência retornando ao final o objeto modificado\npela série de operações que realizamos. Isso nos poupa tempo e evita que sejam\ncriados objetos intermediários para armazenar o resultado das diversas operações.\n\nAlgumas regras são importantes de se notar:\n\n* O `|>` opera da esquerda para a direita, ou seja, o nosso objeto de entrada\nestá sempre a esquerda.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# o nosso data.frame inicia a linha de código a esquerda\n\np365 |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Animal Pai P365\n1      1   A  322\n2      2   A  324\n3      3   A  321\n4      4   A  330\n5      5   A  327\n6      6   A  325\n```\n\n\n:::\n:::\n\n\n\n\n\n\n* O `|>` sempre é o último item em uma linha de código quando quebramos as linhas\npara tornar a sequência mais legível.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos quebrar o código em múltiplas linhas\n# mas o operador de pipe sempre ao final de cada linha\n\np365 |>\n  filter(Pai == \"B\" & P365 >= 320 ) |>\n  pull(P365)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 323 328 320 328 324 322\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Criando ou Modificando Variáveis\n\nA função `mutate` nos permite modificar uma variável ou criar novas variáveis,\nsejam elas a partir de novos valores ou derivadas de nossas variáveis originais.\n\nPor exemplo, no dataset `p365` a variável `P365` está em Kg, podemos criar uma\nnova variável a partir desta que expresse o peso dos animais em arrobas \n(1 arroba = 15 Kg)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np365 |>\n  mutate(P365_ARR = P365/15) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Animal Pai P365 P365_ARR\n1      1   A  322 21.46667\n2      2   A  324 21.60000\n3      3   A  321 21.40000\n4      4   A  330 22.00000\n5      5   A  327 21.80000\n6      6   A  325 21.66667\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPor padrão nossas novas variáveis serão incluídas ao final do nosso conjunto de\ndados, mas este comportamento pode ser modificado passando argumentos para a\nfunção. Quer saber como? Dá uma olhada na documentação da função usando `?mutate`.\n\nVale ressaltar mais uma vez que para que as mudanças sejam fixadas, precisamos ou\natualizar o nosso conjunto de dados ou criar um novo objeto para salvar estas\nmudanças.\n\n\nDuas funções muito úteis que são comumente utilizadas em conjunto com o `mutate`\nsão `case_when` e `if_else`. Estas funções nos permite utilizar filtros ou \ncondições para realizar mudanças no banco de dados. São muito úteis quando \nprecisamos criar novas variáveis como classes, ou alterar observações nos dados\nque estão dentro de faixas específicas de valores/classes.\n\nNovamente, fique a vontade pra consultar a documentação destas duas funções.\n\n## Salvando dados\n\nComo mencionado anteriormente, formatos de texto são sempre os mais compatíveis\nentre plataformas e portanto os mais recomendados.\n\nAs funções `write_csv` e `write.table` nos permitem salvar arquivos em `.csv` e\nem `.txt` respectivamente. A diferença básica entre os dois é que ao salvar em\n_csv_ a função padroniza o arquivo separado por vírgulas. Ja em formato texto\né possível definir o separador de valores do arquivo.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Salvando em .csv\n\np365 |>\n  mutate(P365_ARR = P365/15) |>\n  write_csv(file = \"p365_novo.csv\")\n\n# Salvando como .txt\n\np365 |>\n  mutate(P365_ARR = P365/15) |>\n  write.table(file = \"p365_novo.txt\")\n```\n:::\n\n\n\n\n\n\nImportante lembrar que os arquivos serão salvos na pasta raiz do projeto, ou no\ndiretório configurado como diretório de trabalho. \n\nExiste uma função `write_delim` do pacote `readr` que é similar a `write.table`,\nfique a vontade para explorar a documentação e comparar as características das\nduas funções.",
    "supporting": [
      "02_intro_tidy_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}